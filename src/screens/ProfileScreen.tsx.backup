import React, { useState, useEffect } from 'react';
import { 
  View, 
  StyleSheet, 
  ScrollView, 
  RefreshControl, 
  TouchableOpacity, 
  Alert, 
  Dimensions, 
  Image,
  ImageBackground,
  Modal,
  PanResponder,
  Animated,
  Platform,
  Vibration
} from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import { useNavigation } from '@react-navigation/native';
import { Text, Avatar, Chip, Button, Divider, ProgressBar, Card } from 'react-native-paper';
import * as Animatable from 'react-native-animatable';
import { useAppStore } from '../store/useAppStore';
import { apiService } from '../services/ApiService';

import { useCoreEngine } from '../core/CoreEngine';
import { AnimatedText } from '../components/ui/AnimatedText';
import { LoadingSpinner } from '../components/ui/LoadingComponents';
import { BottomActionBar } from '../components/ui/BottomActionBar';
import { firestoreService } from '../services/FirestoreService';
import { EnterpriseCard } from '../components/enterprise/EnterpriseCard';
import { EnterpriseButton } from '../components/enterprise/EnterpriseButton';
import { EnterpriseLayout, EnterpriseSection, EnterpriseGrid, EnterpriseRow } from '../components/enterprise/EnterpriseLayout';
import { spacing } from '../core/theme';
import { databaseManager } from '../database/DatabaseManager';
import { performanceMonitor } from '../utils/PerformanceMonitor';
import { logger } from '../utils/Logger';

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

interface UserProfile {
  id: string;
  firstName: string;
  lastName: string;
  username: string;
  email: string;
  profile: {
    bio?: string;
    location?: string;
    birthDate?: string;
    gender?: string;
    interests: string[];
    profilePhotos: string[];
  };
  statistics: {
    moviesWatched: number;
    moviesRated: number;
    averageRating: number;
    totalWatchTime: number;
    favoriteActors: string[];
    favoriteDirectors: string[];
    favoriteGenres: string[];
  };
  social: {
    isVerified: boolean;
    isPremium: boolean;
    socialLinks?: {
      letterboxd?: string;
    };
  };
  preferences: {
    favoriteGenres: string[];
    favoriteYears: string[];
    favoriteLanguages: string[];
    watchlistCount: number;
    favoritesCount: number;
    selectedMovies?: any[];
  };
  activity: {
    lastWatched?: {
      title: string;
      posterPath: string;
      watchedAt: string;
    };
    recentActivity: Array<{
      type: 'watched' | 'rated' | 'added_to_watchlist' | 'liked';
      title: string;
      timestamp: string;
      posterPath?: string;
    }>;
  };
}

export const ProfileScreen: React.FC = () => {
  const navigation = useNavigation();
  const { coreService, authService } = useCoreEngine();
  const { user, settings } = useAppStore();
  const [refreshing, setRefreshing] = useState(false);
  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);
  const [loading, setLoading] = useState(true);
  const [zoomedImage, setZoomedImage] = useState<string | null>(null);
  const [currentPhotoIndex, setCurrentPhotoIndex] = useState(0);
  const [photoTranslateX] = useState(new Animated.Value(0));
  const [showPhotoManagementModal, setShowPhotoManagementModal] = useState(false);
  const [editingPhotos, setEditingPhotos] = useState<string[]>([]);
  const [draggedIndex, setDraggedIndex] = useState<number | null>(null);
  
  // Advanced photo animation values for crossfade effect
  const [photoAnimations] = useState(() => ({
    currentPhotoOpacity: new Animated.Value(1),
    nextPhotoOpacity: new Animated.Value(0),
    scale: new Animated.Value(1),
    rotate: new Animated.Value(0),
  }));
  
  const [isTransitioning, setIsTransitioning] = useState(false);
  const [nextPhotoIndex, setNextPhotoIndex] = useState<number | null>(null);
  
  // Profile visibility states
  const [showGender, setShowGender] = useState(true);
  const [showBirthDate, setShowBirthDate] = useState(true);
  const [selectedMediaType, setSelectedMediaType] = useState<'movie' | 'tv'>('movie');
  
  // Drag and drop states
  const [dragPosition, setDragPosition] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const [dropZoneIndex, setDropZoneIndex] = useState<number | null>(null);
  
  // Advanced animation values for drag and drop - Dynamic based on editingPhotos
  const [dragAnimations, setDragAnimations] = useState<Array<{
    scale: Animated.Value;
    opacity: Animated.Value;
    translateX: Animated.Value;
    translateY: Animated.Value;
  }>>(() => 
    Array.from({ length: 7 }, () => ({
      scale: new Animated.Value(1),
      opacity: new Animated.Value(1),
      translateX: new Animated.Value(0),
      translateY: new Animated.Value(0),
    }))
  );
  
  // Floating photo animation
  const [floatingPhoto] = useState({
    scale: new Animated.Value(1),
    opacity: new Animated.Value(0),
    translateX: new Animated.Value(0),
    translateY: new Animated.Value(0),
    rotate: new Animated.Value(0),
  });

  // Effect to load photos when modal opens
  useEffect(() => {
    if (showPhotoManagementModal && userProfile?.profile?.profilePhotos) {
      console.log('ProfileScreen: useEffect - Loading photos into editingPhotos');
      console.log('ProfileScreen: useEffect - userProfile.profile.profilePhotos:', userProfile.profile.profilePhotos);
      setEditingPhotos([...userProfile.profile.profilePhotos]);
    }
  }, [showPhotoManagementModal, userProfile?.profile?.profilePhotos]);

  // Effect to update dragAnimations when editingPhotos changes
  useEffect(() => {
    console.log('ProfileScreen: useEffect - Updating dragAnimations for editingPhotos length:', editingPhotos.length);
    
    // Eƒüer editingPhotos bo≈üsa, hi√ßbir ≈üey yapma
    if (editingPhotos.length === 0) {
      console.log('ProfileScreen: editingPhotos is empty, skipping dragAnimations update');
      return;
    }
    
    // Mevcut dragAnimations'ƒ± koru, sadece gerekli kadar g√ºncelle
    const currentLength = dragAnimations.length;
    const neededLength = Math.max(editingPhotos.length, 7); // En az 7 eleman
    
    if (currentLength < neededLength) {
      console.log('ProfileScreen: Expanding dragAnimations from', currentLength, 'to', neededLength);
      const newDragAnimations = [...dragAnimations];
      
      // Eksik elemanlarƒ± ekle
      for (let i = currentLength; i < neededLength; i++) {
        newDragAnimations.push({
          scale: new Animated.Value(1),
          opacity: new Animated.Value(1),
          translateX: new Animated.Value(0),
          translateY: new Animated.Value(0),
        });
      }
      
      setDragAnimations(newDragAnimations);
      console.log('ProfileScreen: dragAnimations expanded to length:', newDragAnimations.length);
    } else {
      console.log('ProfileScreen: dragAnimations already has sufficient length:', currentLength);
    }
  }, [editingPhotos]);

  useEffect(() => {
    performanceMonitor.trackScreenLoad('ProfileScreen');
    console.log('ProfileScreen: Starting to load user profile...');
    loadUserProfile();
    return () => {
      performanceMonitor.endScreenLoad('ProfileScreen');
    };
  }, []);

  const loadUserProfile = async () => {
    try {
      setLoading(true);
      performanceMonitor.startMetric('profile_load');
      console.log('ProfileScreen: Loading user profile...');

      // Get current user from auth
      const currentUser = await authService.getCurrentUser();
      console.log('ProfileScreen: Current user:', currentUser?.uid);
      
      if (!currentUser) {
        console.log('ProfileScreen: No current user, using default profile');
        // Create default profile for unauthenticated users
        setUserProfile(createDefaultProfile());
        setLoading(false);
        return;
      }

      // Fetch real user profile from Firestore
      try {
        console.log('ProfileScreen: Fetching user profile from Firestore...');
        const userProfile = await firestoreService.getUserProfile(currentUser.uid);
        console.log('ProfileScreen: Firestore user profile:', userProfile);
        console.log('ProfileScreen: Bio from Firestore:', userProfile?.profile?.bio);
        console.log('ProfileScreen: Gender from Firestore:', userProfile?.profile?.gender);
        console.log('ProfileScreen: Interests from Firestore:', userProfile?.profile?.interests);
        
        if (userProfile) {
          // Convert Firestore profile to our interface format
      const profile: UserProfile = {
            id: userProfile.uid,
            firstName: userProfile.firstName || '',
            lastName: userProfile.lastName || '',
            username: userProfile.username || '',
            email: userProfile.email || '',
        profile: {
              bio: userProfile.profile?.bio || '',
              location: userProfile.profile?.location || '',
              birthDate: userProfile.profile?.birthDate || '',
              gender: userProfile.profile?.gender || '',
              interests: userProfile.profile?.interests || [],
              profilePhotos: userProfile.profilePhotos || [],
        },
        statistics: {
              moviesWatched: userProfile.statistics?.moviesWatched || 0,
              moviesRated: userProfile.statistics?.moviesRated || 0,
              averageRating: userProfile.statistics?.averageRating || 0,
              totalWatchTime: 0, // Not in current schema
              favoriteActors: userProfile.statistics?.favoriteActors || [],
              favoriteDirectors: userProfile.statistics?.favoriteDirectors || [],
              favoriteGenres: userProfile.preferences?.favoriteGenres || [],
        },
        social: {
              isVerified: userProfile.social?.isVerified || false,
              isPremium: false, // Not in current schema
        },
        preferences: {
              favoriteGenres: userProfile.preferences?.favoriteGenres || [],
              favoriteYears: userProfile.preferences?.favoriteYears || [],
              favoriteLanguages: [], // Not in current schema
          watchlistCount: 0, // Will be filled from database
          favoritesCount: 0, // Will be filled from database
              selectedMovies: userProfile.selectedMovies || [],
        },
        activity: {
          lastWatched: undefined, // Will be filled from database
          recentActivity: [], // Will be filled from database
        },
      };

      setUserProfile(profile);
          console.log('ProfileScreen: Final profile object:', profile);
          console.log('ProfileScreen: Final bio:', profile.profile.bio);
          console.log('ProfileScreen: Final gender:', profile.profile.gender);
          console.log('ProfileScreen: Final interests:', profile.profile.interests);
          logger.info('Profile loaded successfully from Firestore', 'ProfileScreen');
        } else {
          // If no profile found, create default
          logger.warn('No user profile found in Firestore, using default', 'ProfileScreen');
          setUserProfile(createDefaultProfile());
        }
      } catch (firestoreError) {
        logger.error('Error fetching user profile from Firestore', 'ProfileScreen', firestoreError);
        // Fallback to default profile
        setUserProfile(createDefaultProfile());
      }
      
      const duration = performanceMonitor.endMetric('profile_load');
      logger.info(`Profile loaded in ${duration}ms`, 'ProfileScreen');
      
    } catch (error) {
      logger.error('Failed to load profile', 'ProfileScreen', error);
      setUserProfile(createDefaultProfile());
    } finally {
      setLoading(false);
    }
  };

  const createDefaultProfile = (): UserProfile => ({
    id: 'guest',
    firstName: '',
    lastName: '',
    username: '',
    email: '',
    profile: {
      bio: '',
      location: '',
      birthDate: '',
      gender: '',
      interests: [],
      profilePhotos: [],
    },
    statistics: {
      moviesWatched: 0,
      moviesRated: 0,
      averageRating: 0,
      totalWatchTime: 0,
      favoriteActors: [],
      favoriteDirectors: [],
      favoriteGenres: [],
    },
    social: {
      isVerified: false,
      isPremium: false,
    },
    preferences: {
      favoriteGenres: [],
      favoriteYears: [],
      favoriteLanguages: [],
      watchlistCount: 0,
      favoritesCount: 0,
    },
    activity: {
      recentActivity: [],
    },
  });



  const loadRealStatistics = async (userId: string) => {
    try {
      // Load real statistics from database
      const statistics = await databaseManager.getUserStatistics(userId);
      
      if (statistics && userProfile) {
        setUserProfile(prev => prev ? {
          ...prev,
          statistics: {
            ...prev.statistics,
            moviesWatched: statistics.moviesWatched,
            moviesRated: statistics.moviesRated,
            averageRating: statistics.averageRating,
            totalWatchTime: statistics.totalWatchTime,
            favoriteActors: statistics.favoriteActors,
            favoriteDirectors: statistics.favoriteDirectors,
            favoriteGenres: statistics.favoriteGenres,
          },
        } : prev);
      }
    } catch (error) {
      logger.error('Failed to load real statistics', 'ProfileScreen', error);
    }
  };

  const onRefresh = async () => {
    setRefreshing(true);
    try {
      performanceMonitor.startMetric('profile_refresh');
      await loadUserProfile();
      const duration = performanceMonitor.endMetric('profile_refresh');
      logger.info(`Profile refreshed in ${duration}ms`, 'ProfileScreen');
    } catch (error) {
      logger.error('Refresh error', 'ProfileScreen', error);
    } finally {
      setRefreshing(false);
    }
  };

  const handleEditProfile = (section: 'name' | 'username' | 'bio' | 'gender' | 'interests') => {
    // Navigate to edit screen
    navigation.navigate('EditProfile' as never, {
      section,
      currentData: {
        firstName: userProfile?.firstName,
        lastName: userProfile?.lastName,
        username: userProfile?.username,
        bio: userProfile?.profile.bio,
        gender: userProfile?.profile.gender,
        interests: userProfile?.profile.interests,
        letterboxdLink: userProfile?.social?.socialLinks?.letterboxd
      },
      onSave: (data: any) => {
        // Update local state
        if (userProfile) {
          setUserProfile(prev => prev ? {
            ...prev,
            ...data,
            profile: {
              ...prev.profile,
              ...data.profile
            }
          } : prev);
        }
      }
    });
  };


  const handleImagePress = (imageUri: string) => {
    setZoomedImage(imageUri);
  };

  const closeZoomedImage = () => {
    setZoomedImage(null);
  };

  // Photo swipe functionality
  const photos = userProfile?.profile?.profilePhotos || [];
  
  const panResponder = PanResponder.create({
    onMoveShouldSetPanResponder: (_, gestureState) => {
      return Math.abs(gestureState.dx) > 20;
    },
    onPanResponderMove: (_, gestureState) => {
      // Real-time swipe feedback with next photo preview
      const { dx } = gestureState;
      const swipeProgress = Math.abs(dx) / 150; // 0 to 1 based on swipe distance
      const clampedProgress = Math.min(1, swipeProgress);
      
      // Update photo opacity based on swipe progress
      if (dx > 0 && currentPhotoIndex > 0) {
        // Swiping right - fade current photo, show previous photo
        photoAnimations.currentPhotoOpacity.setValue(Math.max(0.2, 1 - clampedProgress));
        if (!nextPhotoIndex || nextPhotoIndex !== currentPhotoIndex - 1) {
          setNextPhotoIndex(currentPhotoIndex - 1);
          photoAnimations.nextPhotoOpacity.setValue(clampedProgress * 0.8);
        } else {
          photoAnimations.nextPhotoOpacity.setValue(clampedProgress * 0.8);
        }
      } else if (dx < 0 && currentPhotoIndex < photos.length - 1) {
        // Swiping left - fade current photo, show next photo
        photoAnimations.currentPhotoOpacity.setValue(Math.max(0.2, 1 - clampedProgress));
        if (!nextPhotoIndex || nextPhotoIndex !== currentPhotoIndex + 1) {
          setNextPhotoIndex(currentPhotoIndex + 1);
          photoAnimations.nextPhotoOpacity.setValue(clampedProgress * 0.8);
        } else {
          photoAnimations.nextPhotoOpacity.setValue(clampedProgress * 0.8);
        }
      }
      
      // Update translate for visual feedback
      photoTranslateX.setValue(dx * 0.2); // Reduced movement for better UX
    },
    onPanResponderRelease: (_, gestureState) => {
      const { dx, vx } = gestureState;
      const swipeThreshold = 50;
      const velocityThreshold = 0.3;

      if (Math.abs(dx) > swipeThreshold || Math.abs(vx) > velocityThreshold) {
        if (dx > 0 && currentPhotoIndex > 0 && !isTransitioning) {
          // Swipe right - previous photo
          animatePhotoTransition(currentPhotoIndex - 1);
        } else if (dx < 0 && currentPhotoIndex < photos.length - 1 && !isTransitioning) {
          // Swipe left - next photo
          animatePhotoTransition(currentPhotoIndex + 1);
        } else {
          // Reset if no transition
          resetPhotoPosition();
        }
      } else {
        // Reset if swipe not strong enough
        resetPhotoPosition();
      }
    },
  });

  const goToPhoto = (index: number) => {
    if (index >= 0 && index < photos.length && index !== currentPhotoIndex && !isTransitioning) {
      animatePhotoTransition(index);
    }
  };

  const resetPhotoPosition = () => {
    Animated.parallel([
      Animated.spring(photoTranslateX, {
        toValue: 0,
        useNativeDriver: true,
      }),
      Animated.timing(photoAnimations.currentPhotoOpacity, {
        toValue: 1,
        duration: 200,
        useNativeDriver: true,
      }),
      Animated.timing(photoAnimations.nextPhotoOpacity, {
        toValue: 0,
        duration: 200,
        useNativeDriver: true,
      }),
    ]).start(() => {
      setNextPhotoIndex(null);
    });
  };

  const animatePhotoTransition = (newIndex: number) => {
    if (isTransitioning || newIndex === currentPhotoIndex) return;
    
    setIsTransitioning(true);
    setNextPhotoIndex(newIndex);
    
    // Reset next photo opacity to 0
    photoAnimations.nextPhotoOpacity.setValue(0);
    
    // Crossfade animation: current photo fades out while next photo fades in
    Animated.parallel([
      // Current photo fades out
      Animated.timing(photoAnimations.currentPhotoOpacity, {
        toValue: 0,
        duration: 300,
        useNativeDriver: true,
      }),
      // Next photo fades in
      Animated.timing(photoAnimations.nextPhotoOpacity, {
        toValue: 1,
        duration: 300,
        useNativeDriver: true,
      }),
      // Scale animation for smooth effect
      Animated.sequence([
        Animated.timing(photoAnimations.scale, {
          toValue: 1.05,
          duration: 150,
          useNativeDriver: true,
        }),
        Animated.spring(photoAnimations.scale, {
          toValue: 1,
          useNativeDriver: true,
        }),
      ]),
      // Reset translate position
      Animated.spring(photoTranslateX, {
        toValue: 0,
        useNativeDriver: true,
      }),
    ]).start(() => {
      // Update current photo index
      setCurrentPhotoIndex(newIndex);
      
      // Reset animations for next transition
      photoAnimations.currentPhotoOpacity.setValue(1);
      photoAnimations.nextPhotoOpacity.setValue(0);
      setNextPhotoIndex(null);
      setIsTransitioning(false);
    });
  };

  // Photo Management Functions
  const openPhotoManagement = () => {
    console.log('ProfileScreen: Opening photo management modal');
    console.log('ProfileScreen: userProfile.profile.profilePhotos:', userProfile?.profile?.profilePhotos);
    setShowPhotoManagementModal(true);
  };

  const closePhotoManagement = () => {
    setShowPhotoManagementModal(false);
    setEditingPhotos([]);
  };

  const deletePhoto = (index: number) => {
    const newPhotos = editingPhotos.filter((_, i) => i !== index);
    setEditingPhotos(newPhotos);
  };

  const reorderPhotos = (fromIndex: number, toIndex: number) => {
    console.log('ProfileScreen: reorderPhotos called - fromIndex:', fromIndex, 'toIndex:', toIndex);
    console.log('ProfileScreen: Current editingPhotos:', editingPhotos);
    
    const newPhotos = [...editingPhotos];
    const [removed] = newPhotos.splice(fromIndex, 1);
    newPhotos.splice(toIndex, 0, removed);
    
    console.log('ProfileScreen: New photo order:', newPhotos);
    setEditingPhotos(newPhotos);
  };

  const handleDragStart = (index: number) => {
    console.log('ProfileScreen: handleDragStart called with index:', index);
    console.log('ProfileScreen: dragAnimations length:', dragAnimations.length);
    console.log('ProfileScreen: editingPhotos length:', editingPhotos.length);
    
    setDraggedIndex(index);
    setIsDragging(true);
    
    // Floating photo'yu g√∂ster - Exact same as RegisterScreen
    Animated.parallel([
      Animated.spring(floatingPhoto.scale, {
        toValue: 1.2,
        useNativeDriver: true,
      }),
      Animated.timing(floatingPhoto.opacity, {
        toValue: 1,
        duration: 200,
        useNativeDriver: true,
      }),
      Animated.spring(floatingPhoto.rotate, {
        toValue: 1,
        useNativeDriver: true,
      }),
    ]).start();
    
    // Orijinal fotoƒürafƒ± gizle - Exact same as RegisterScreen
    if (dragAnimations[index]) {
      Animated.parallel([
        Animated.spring(dragAnimations[index].scale, {
          toValue: 0.8,
          useNativeDriver: true,
        }),
        Animated.timing(dragAnimations[index].opacity, {
          toValue: 0.3,
          duration: 200,
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      console.log('ProfileScreen: dragAnimations[index] is undefined for index:', index);
      console.log('ProfileScreen: dragAnimations array:', dragAnimations);
    }
  };

  const handleDragEnd = () => {
    if (draggedIndex !== null) {
      // Floating photo'yu gizle - Exact same as RegisterScreen
      Animated.parallel([
        Animated.spring(floatingPhoto.scale, {
          toValue: 1,
          useNativeDriver: true,
        }),
        Animated.timing(floatingPhoto.opacity, {
          toValue: 0,
          duration: 200,
          useNativeDriver: true,
        }),
        Animated.spring(floatingPhoto.rotate, {
          toValue: 0,
          useNativeDriver: true,
        }),
      ]).start();
      
      // Orijinal fotoƒürafƒ± normale d√∂nd√ºr - Exact same as RegisterScreen
      Animated.parallel([
        Animated.spring(dragAnimations[draggedIndex].scale, {
          toValue: 1,
          useNativeDriver: true,
        }),
        Animated.timing(dragAnimations[draggedIndex].opacity, {
          toValue: 1,
          duration: 200,
          useNativeDriver: true,
        }),
      ]).start();
      
      // Diƒüer fotoƒüraflarƒ± normale d√∂nd√ºr - Exact same as RegisterScreen
      editingPhotos.forEach((_, i) => {
        if (i !== draggedIndex && dragAnimations[i]) {
          Animated.parallel([
            Animated.spring(dragAnimations[i].translateX, {
              toValue: 0,
              useNativeDriver: true,
            }),
            Animated.spring(dragAnimations[i].translateY, {
              toValue: 0,
              useNativeDriver: true,
            }),
          ]).start();
        }
      });
    }
    
    setDraggedIndex(null);
    setIsDragging(false);
    setDropZoneIndex(null);
    setDragPosition({ x: 0, y: 0 });
  };

  const handleDrop = (dropIndex: number) => {
    if (draggedIndex !== null && draggedIndex !== dropIndex) {
      reorderPhotos(draggedIndex, dropIndex);
    }
    setDraggedIndex(null);
  };

  // Advanced PanResponder for drag and drop - Exact copy from RegisterScreen
  const createPanResponder = (index: number) => {
    // Eƒüer dragAnimations hazƒ±r deƒüilse, bo≈ü PanResponder d√∂nd√ºr
    if (!dragAnimations[index]) {
      console.log('ProfileScreen: createPanResponder - dragAnimations[index] not ready for index:', index);
      return PanResponder.create({});
    }
    
    return PanResponder.create({
      onMoveShouldSetPanResponder: (_, gestureState) => {
        const shouldSet = Math.abs(gestureState.dx) > 10 || Math.abs(gestureState.dy) > 10;
        console.log('ProfileScreen: onMoveShouldSetPanResponder for index', index, 'shouldSet:', shouldSet, 'dx:', gestureState.dx, 'dy:', gestureState.dy);
        return shouldSet;
      },
      onPanResponderGrant: (evt) => {
        console.log('ProfileScreen: onPanResponderGrant for index:', index);
        handleDragStart(index);
        setDragPosition({ x: evt.nativeEvent.pageX, y: evt.nativeEvent.pageY });
      },
      onPanResponderMove: (evt, gestureState) => {
        console.log('ProfileScreen: onPanResponderMove - gestureState:', gestureState);
        
        // Floating photo'yu hareket ettir
        floatingPhoto.translateX.setValue(gestureState.dx);
        floatingPhoto.translateY.setValue(gestureState.dy);
        
        // Grid pozisyonunu hesapla - Exact same as RegisterScreen
        const photoWidth = (screenWidth - spacing.lg * 2 - spacing.sm * 2) / 3;
        const photoHeight = photoWidth * 1.33;
        const totalWidth = photoWidth + spacing.sm;
        const totalHeight = photoHeight + spacing.sm;
        
        console.log('ProfileScreen: Grid calculations - photoWidth:', photoWidth, 'totalWidth:', totalWidth, 'totalHeight:', totalHeight);
        
        // Grid pozisyonunu hesapla
        const col = Math.floor(gestureState.moveX / totalWidth);
        const row = Math.floor(gestureState.moveY / totalHeight);
        const newIndex = Math.min(Math.max(0, row * 3 + col), editingPhotos.length - 1);
        
        console.log('ProfileScreen: Grid position - col:', col, 'row:', row, 'newIndex:', newIndex, 'dropZoneIndex:', dropZoneIndex);
        
        // Drop zone'u g√ºncelle
        if (newIndex !== dropZoneIndex) {
          console.log('ProfileScreen: Updating drop zone from', dropZoneIndex, 'to', newIndex);
          setDropZoneIndex(newIndex);
          
          // Diƒüer fotoƒüraflarƒ± kaydƒ±r - Exact same logic as RegisterScreen
          editingPhotos.forEach((_, i) => {
            if (i !== draggedIndex && dragAnimations[i]) {
              const targetCol = i % 3;
              const targetRow = Math.floor(i / 3);
              const newCol = newIndex % 3;
              const newRow = Math.floor(newIndex / 3);
              
              let translateX = 0;
              let translateY = 0;
              
              // Fotoƒürafƒ± kaydƒ±r
              if (i < newIndex && i > (draggedIndex || 0)) {
                // Saƒüa kaydƒ±r
                translateX = -totalWidth;
              } else if (i > newIndex && i < (draggedIndex || 0)) {
                // Sola kaydƒ±r
                translateX = totalWidth;
              } else if (i < newIndex && Math.floor(i / 3) < Math.floor(newIndex / 3)) {
                // A≈üaƒüƒ± kaydƒ±r
                translateY = -totalHeight;
              } else if (i > newIndex && Math.floor(i / 3) > Math.floor(newIndex / 3)) {
                // Yukarƒ± kaydƒ±r
                translateY = totalHeight;
              }
              
              console.log('ProfileScreen: Moving photo', i, 'translateX:', translateX, 'translateY:', translateY);
              
              Animated.spring(dragAnimations[i].translateX, {
                toValue: translateX,
                useNativeDriver: true,
              }).start();
              
              Animated.spring(dragAnimations[i].translateY, {
                toValue: translateY,
                useNativeDriver: true,
              }).start();
            }
          });
          
          // Haptic feedback
          if (Platform.OS === 'ios') {
            Vibration.vibrate(10);
          }
        }
      },
      onPanResponderRelease: () => {
        console.log('ProfileScreen: onPanResponderRelease - dropZoneIndex:', dropZoneIndex, 'draggedIndex:', draggedIndex);
        if (dropZoneIndex !== null && dropZoneIndex !== draggedIndex) {
          console.log('ProfileScreen: Reordering photos from', draggedIndex, 'to', dropZoneIndex);
          reorderPhotos(draggedIndex!, dropZoneIndex);
        } else {
          console.log('ProfileScreen: No reordering needed');
        }
        handleDragEnd();
      },
      onPanResponderTerminate: () => {
        console.log('ProfileScreen: onPanResponderTerminate');
        handleDragEnd();
      },
    });
  };


  const addNewPhoto = async () => {
    try {
      // Maksimum 7 fotoƒüraf kontrol√º
      if (editingPhotos.length >= 7) {
        Alert.alert('Uyarƒ±', 'Maksimum 7 fotoƒüraf y√ºkleyebilirsiniz');
        return;
      }

      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsEditing: true,
        aspect: [3, 4],
        quality: 0.95,
        allowsMultipleSelection: false,
        exif: true,
      });

      if (!result.canceled && result.assets && result.assets.length > 0) {
        const newPhoto = result.assets[0].uri;
        setEditingPhotos(prev => [...prev, newPhoto]);
      }
    } catch (error) {
      console.error('Error picking image:', error);
      Alert.alert('Hata', 'Fotoƒüraf se√ßimi sƒ±rasƒ±nda hata olu≈ütu');
    }
  };

  const savePhotoChanges = async () => {
    try {
      // Minimum 3 fotoƒüraf kontrol√º
      if (editingPhotos.length < 3) {
        Alert.alert('Uyarƒ±', 'En az 3 fotoƒüraf y√ºklemeniz gerekiyor');
        return;
      }

      // Maksimum 7 fotoƒüraf kontrol√º
      if (editingPhotos.length > 7) {
        Alert.alert('Uyarƒ±', 'Maksimum 7 fotoƒüraf y√ºkleyebilirsiniz');
        return;
      }

      // TODO: Implement photo upload and update user profile
      // For now, just update local state
      if (userProfile) {
        setUserProfile(prev => prev ? {
          ...prev,
          profile: {
            ...prev.profile,
            profilePhotos: editingPhotos
          }
        } : prev);
      }
      closePhotoManagement();
      Alert.alert('Ba≈üarƒ±lƒ±', 'Fotoƒüraflar g√ºncellendi');
    } catch (error) {
      console.error('Error saving photos:', error);
      Alert.alert('Hata', 'Fotoƒüraflar kaydedilirken hata olu≈ütu');
    }
  };


  const handleMessage = () => {
    Alert.alert('Mesaj G√∂nder', 'Mesajla≈üma √∂zelliƒüi yakƒ±nda eklenecek!');
  };


  if (loading) {
    return (
      <EnterpriseLayout>
        <LoadingSpinner />
      </EnterpriseLayout>
    );
  }

  if (!userProfile) {
    return (
      <EnterpriseLayout>
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>Profil y√ºklenemedi</Text>
          <EnterpriseButton
            title="Tekrar Dene"
            onPress={loadUserProfile}
            variant="primary"
          />
        </View>
      </EnterpriseLayout>
    );
  }

  return (
    <EnterpriseLayout scrollable={true} padding={0}>
      <ScrollView 
        showsVerticalScrollIndicator={false}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            colors={['#E50914']}
            tintColor="#E50914"
          />
        }
      >

        {/* Photo Gallery Section - Horizontal Scroll Like Movies */}
        <Animatable.View animation="fadeInUp" delay={200} style={styles.photoSection}>
          <View style={styles.photoGalleryContainer}>
            <ScrollView 
              horizontal 
              showsHorizontalScrollIndicator={false}
              style={styles.photoScrollView}
              contentContainerStyle={styles.photoScrollContent}
              pagingEnabled={true}
              decelerationRate="fast"
              onScroll={(event) => {
                const contentOffsetX = event.nativeEvent.contentOffset.x;
                const pageWidth = screenWidth - spacing.lg * 2;
                const currentIndex = Math.round(contentOffsetX / pageWidth);
                setCurrentPhotoIndex(currentIndex);
              }}
              scrollEventThrottle={16}
            >
              {photos.map((photo, index) => (
                <View key={index} style={styles.photoCard}>
                  <TouchableOpacity 
                    onPress={() => handleImagePress(photo)}
                    style={styles.photoCardTouchable}
                  >
                    <Image 
                      source={{ uri: photo }} 
                      style={styles.photoCardImage}
              resizeMode="cover"
                    />
                  </TouchableOpacity>
                  {/* Photo Edit Button */}
                  <TouchableOpacity 
                    style={styles.photoEditButton}
                    onPress={() => setShowPhotoManagementModal(true)}
                  >
                    <Text style={styles.photoEditButtonText}>‚úèÔ∏è</Text>
                  </TouchableOpacity>
                </View>
              ))}
            </ScrollView>
            
            {/* Photo Indicators */}
            {photos.length > 1 && (
              <View style={styles.photoIndicatorsContainer}>
                <View style={styles.photoIndicators}>
                  {photos.map((_, index) => (
                    <View
                      key={index}
                      style={[
                        styles.photoIndicator,
                        index === currentPhotoIndex && styles.photoIndicatorActive
                      ]}
                    />
                  ))}
              </View>
            </View>
          )}
          </View>
        </Animatable.View>

        {/* Profile Info Section */}
        <Animatable.View animation="fadeInUp" delay={400} style={styles.profileInfoContainer}>
          <View style={styles.profileHeader}>
            
            <View style={styles.profileInfo}>
              <EnterpriseRow alignItems="center" spacing={spacing.sm}>
                <AnimatedText variant="h1" style={styles.profileName}>
                  {userProfile.firstName || userProfile.lastName ? 
                    `${userProfile.firstName || ''} ${userProfile.lastName || ''}`.trim() : 
                    'Kullanƒ±cƒ±'}
                </AnimatedText>
                <TouchableOpacity onPress={() => handleEditProfile('name')} style={styles.editButton}>
                  <Text style={styles.editIcon}>‚úèÔ∏è</Text>
                </TouchableOpacity>
                {userProfile.social.isPremium && (
                  <Text style={styles.premiumBadge}>üëë</Text>
                )}
              </EnterpriseRow>
              
              <EnterpriseRow alignItems="center" spacing={spacing.sm}>
                {userProfile.username ? (
                <Text style={styles.profileUsername}>@{userProfile.username}</Text>
                ) : (
                  <Text style={styles.profileUsernamePlaceholder}>Kullanƒ±cƒ± adƒ± eklenmemi≈ü</Text>
              )}
                <TouchableOpacity onPress={() => handleEditProfile('username')} style={styles.editButton}>
                  <Text style={styles.editIcon}>‚úèÔ∏è</Text>
                </TouchableOpacity>
              </EnterpriseRow>
              
              <EnterpriseRow alignItems="flex-start" spacing={spacing.sm}>
                <View style={styles.bioContainer}>
              {userProfile.profile.bio ? (
                <Text style={styles.profileBio}>{userProfile.profile.bio}</Text>
              ) : (
                <Text style={styles.profileBioPlaceholder}>Bio bilgisi eklenmemi≈ü</Text>
              )}
                </View>
                <TouchableOpacity onPress={() => handleEditProfile('bio')} style={styles.editButton}>
                  <Text style={styles.editIcon}>‚úèÔ∏è</Text>
            </TouchableOpacity>
          </EnterpriseRow>
              
              {/* Letterboxd Link */}
              {userProfile.social?.socialLinks?.letterboxd && (
                <View style={styles.letterboxdContainer}>
                  <Text style={styles.letterboxdIcon}>üé¨</Text>
                  <Text style={styles.letterboxdText} onPress={() => {}}>
                    {userProfile.social.socialLinks.letterboxd}
                  </Text>
                </View>
              )}
              
              {/* Personal Information */}
              <View style={styles.personalInfoSection}>
                {/* Gender */}
                {userProfile.profile.gender && (
                  <EnterpriseRow alignItems="center" spacing={spacing.sm} style={styles.personalInfoRow}>
                    <View style={styles.personalInfoContainer}>
                      <View style={styles.personalInfoItem}>
                        <Text style={styles.personalInfoIcon}>üë§</Text>
                        <Text style={styles.personalInfoText}>
                          {showGender ? (
                            userProfile.profile.gender === 'male' ? 'Erkek' : 
                            userProfile.profile.gender === 'female' ? 'Kadƒ±n' : 
                            userProfile.profile.gender === 'other' ? 'Diƒüer' : 
                            userProfile.profile.gender
                          ) : 'Gizli'}
                        </Text>
            </View>
          </View>
                    <TouchableOpacity 
                      onPress={() => setShowGender(!showGender)} 
                      style={styles.visibilityButton}
                    >
                      <Text style={styles.visibilityIcon}>
                        {showGender ? 'üëÅÔ∏è' : 'üôà'}
                      </Text>
            </TouchableOpacity>
                    <TouchableOpacity onPress={() => handleEditProfile('gender')} style={styles.editButton}>
                      <Text style={styles.editIcon}>‚úèÔ∏è</Text>
            </TouchableOpacity>
          </EnterpriseRow>
                )}
                
                {/* Birth Date */}
                {userProfile.profile.birthDate && (
                  <EnterpriseRow alignItems="center" spacing={spacing.sm} style={styles.personalInfoRow}>
                    <View style={styles.personalInfoContainer}>
                      <View style={styles.personalInfoItem}>
                        <Text style={styles.personalInfoIcon}>üìÖ</Text>
                        <Text style={styles.personalInfoText}>
                          {showBirthDate ? 
                            new Date(userProfile.profile.birthDate).toLocaleDateString('tr-TR') : 
                            'Gizli'
                          }
                        </Text>
              </View>
              </View>
                    <TouchableOpacity 
                      onPress={() => setShowBirthDate(!showBirthDate)} 
                      style={styles.visibilityButton}
                    >
                      <Text style={styles.visibilityIcon}>
                        {showBirthDate ? 'üëÅÔ∏è' : 'üôà'}
                    </Text>
                  </TouchableOpacity>
                    <TouchableOpacity onPress={() => handleEditProfile('gender')} style={styles.editButton}>
                      <Text style={styles.editIcon}>‚úèÔ∏è</Text>
                    </TouchableOpacity>
                  </EnterpriseRow>
                )}
              </View>
              </View>
          </View>

        </Animatable.View>


        {/* Interests Section */}
        <Animatable.View animation="fadeInUp" delay={600} style={styles.sectionContainer}>
          <EnterpriseRow justifyContent="space-between" alignItems="center" style={styles.sectionHeader}>
            <AnimatedText variant="h3" style={styles.sectionTitle}>
              üéØ ƒ∞lgi Alanlarƒ±
            </AnimatedText>
            <TouchableOpacity onPress={() => handleEditProfile('interests')} style={styles.editButton}>
              <Text style={styles.editIcon}>‚úèÔ∏è</Text>
            </TouchableOpacity>
          </EnterpriseRow>
            
            <EnterpriseCard variant="outlined" style={styles.interestsCard}>
            {userProfile.profile.interests.length > 0 ? (
              <View style={styles.interestsContainer}>
                {userProfile.profile.interests.map((interest, index) => (
                  <Chip
                    key={index}
                    mode="outlined"
                    style={styles.interestChip}
                    textStyle={styles.interestChipText}
                  >
                    {interest}
                  </Chip>
                ))}
              </View>
            ) : (
              <View style={styles.emptyInterestsContainer}>
                <Text style={styles.emptyInterestsText}>Hen√ºz ilgi alanƒ± eklenmemi≈ü</Text>
                <Text style={styles.emptyInterestsSubtext}>Profil d√ºzenleme sayfasƒ±ndan ilgi alanlarƒ±nƒ±zƒ± ekleyebilirsiniz</Text>
              </View>
            )}
            </EnterpriseCard>
          </Animatable.View>

        {/* Favorite Movies & TV Shows Section */}
        <Animatable.View animation="fadeInUp" delay={800} style={styles.sectionContainer}>
          <EnterpriseRow justifyContent="space-between" alignItems="center" style={styles.sectionHeader}>
            <AnimatedText variant="h3" style={styles.sectionTitle}>
              üé¨ Favori Filmler & Diziler
            </AnimatedText>
            <TouchableOpacity onPress={() => handleEditProfile('interests')} style={styles.editButton}>
              <Text style={styles.editIcon}>‚úèÔ∏è</Text>
            </TouchableOpacity>
          </EnterpriseRow>
            
          {/* Film ve Dizi Ayrƒ±mƒ± - √ústte Yan Yana */}
          <View style={styles.favoritesFilterRow}>
            <TouchableOpacity 
              style={[styles.favoritesFilterButton, selectedMediaType === 'movie' && styles.favoritesFilterButtonActive]}
              onPress={() => setSelectedMediaType('movie')}
            >
              <Text style={[styles.favoritesFilterButtonText, selectedMediaType === 'movie' && styles.favoritesFilterButtonTextActive]}>üé¨ Filmler</Text>
            </TouchableOpacity>
            <TouchableOpacity 
              style={[styles.favoritesFilterButton, selectedMediaType === 'tv' && styles.favoritesFilterButtonActive]}
              onPress={() => setSelectedMediaType('tv')}
            >
              <Text style={[styles.favoritesFilterButtonText, selectedMediaType === 'tv' && styles.favoritesFilterButtonTextActive]}>üì∫ Diziler</Text>
            </TouchableOpacity>
              </View>

          <EnterpriseCard variant="outlined" style={styles.favoritesCard}>
            {userProfile.preferences?.selectedMovies && userProfile.preferences.selectedMovies.length > 0 ? (
              <View style={styles.favoritesContainer}>
                {/* Film/Dizi Kartlarƒ± - Registration Screen Style */}
                <ScrollView 
                  horizontal 
                  showsHorizontalScrollIndicator={false}
                  style={styles.favoritesScrollView}
                  contentContainerStyle={styles.favoritesScrollContent}
                >
                  {userProfile.preferences.selectedMovies
                    .filter((movie: any) => {
                      if (selectedMediaType === 'movie') {
                        return movie.media_type === 'movie' || (!movie.media_type && movie.title);
                      } else {
                        return movie.media_type === 'tv' || (!movie.media_type && movie.name);
                      }
                    })
                    .map((movie: any, index: number) => (
                    <TouchableOpacity key={index} style={styles.favoriteMovieCard}>
                    <Image
                        source={{ uri: movie.poster_path ? `https://image.tmdb.org/t/p/w300${movie.poster_path}` : 'https://via.placeholder.com/150x225' }}
                        style={styles.favoriteMoviePoster}
                      />
                      <View style={styles.favoriteMovieCardInfo}>
                        <Text style={styles.favoriteMovieCardTitle} numberOfLines={2}>
                          {movie.title || movie.name}
                        </Text>
                        <Text style={styles.favoriteMovieCardYear}>
                          {movie.release_date ? new Date(movie.release_date).getFullYear() : 
                           movie.first_air_date ? new Date(movie.first_air_date).getFullYear() : 'N/A'}
                        </Text>
                        <View style={styles.favoriteMovieCardType}>
                          <Text style={styles.favoriteMovieCardTypeText}>
                            {selectedMediaType === 'movie' ? 'üé¨ Film' : 'üì∫ Dizi'}
                          </Text>
                </View>
                      </View>
                    </TouchableOpacity>
                  ))}
                </ScrollView>
              </View>
            ) : (
              <View style={styles.emptyFavoritesContainer}>
                <Text style={styles.emptyFavoritesText}>Hen√ºz favori film/dizi eklenmemi≈ü</Text>
                <Text style={styles.emptyFavoritesSubtext}>Kayƒ±t sƒ±rasƒ±nda se√ßtiƒüiniz filmler burada g√∂r√ºnecek</Text>
              </View>
            )}
            </EnterpriseCard>
          </Animatable.View>






        {/* Bottom Spacing */}
        <View style={styles.bottomSpacing} />
      </ScrollView>
      
      {/* Fixed bottom section with safe area handling */}
      <BottomActionBar
        showCopyright={true}
        copyrightText="¬© 2025 WMatch"
        poweredByText="Powered by MWatch"
        copyrightDelay={1200}
      />
      
      {/* Photo Zoom Modal */}
      <Modal
        visible={!!zoomedImage}
        transparent={true}
        animationType="fade"
        onRequestClose={closeZoomedImage}
      >
        <TouchableOpacity 
          style={styles.zoomModalOverlay}
          activeOpacity={1}
          onPress={closeZoomedImage}
        >
          <View style={styles.zoomModalContainer}>
            <TouchableOpacity 
              style={styles.zoomCloseButton}
              onPress={closeZoomedImage}
            >
              <Text style={styles.zoomCloseText}>‚úï</Text>
            </TouchableOpacity>
            {zoomedImage && (
                <Image
                source={{ uri: zoomedImage }}
                style={styles.zoomedImage}
                resizeMode="contain"
                    />
                  )}
                </View>
        </TouchableOpacity>
      </Modal>

      {/* Photo Management Modal */}
      <Modal
        visible={showPhotoManagementModal}
        transparent={true}
        animationType="slide"
        onRequestClose={closePhotoManagement}
        onShow={() => {
          console.log('ProfileScreen: Modal shown, editingPhotos:', editingPhotos);
          console.log('ProfileScreen: Modal shown, userProfile.profile.profilePhotos:', userProfile?.profile?.profilePhotos);
        }}
      >
        <View style={styles.photoManagementModal}>
          <View style={styles.photoManagementContainer}>
            <View style={styles.photoUploadHeader}>
              <Text style={styles.photoUploadTitle}>Fotoƒüraflarƒ±nƒ±z</Text>
              <Text style={styles.photoUploadSubtitle}>
                En az 3, en fazla 7 fotoƒüraf y√ºkleyin ({editingPhotos.length}/7)
                  </Text>
            </View>
              <TouchableOpacity 
                style={styles.photoManagementCloseButton}
                onPress={closePhotoManagement}
              >
                <Text style={styles.photoManagementCloseText}>‚úï</Text>
              </TouchableOpacity>
            
            <ScrollView style={styles.photoManagementContent}>
              {editingPhotos.length < 3 && (
                <View style={styles.photoManagementWarning}>
                  <Text style={styles.photoManagementWarningText}>
                    ‚ö†Ô∏è En az 3 fotoƒüraf y√ºklemeniz gerekiyor
                  </Text>
                </View>
              )}
              
              {/* Photo Grid - Exact same as RegisterScreen */}
              <View style={styles.photoGrid}>
                {editingPhotos.map((photo, index) => (
                  <Animated.View 
                    key={index} 
                    style={[
                      styles.photoItem,
                      {
                        transform: [
                          { scale: dragAnimations[index].scale },
                          { translateX: dragAnimations[index].translateX },
                          { translateY: dragAnimations[index].translateY },
                        ],
                        opacity: dragAnimations[index].opacity,
                      },
                      draggedIndex === index && styles.photoItemDragging,
                      dropZoneIndex === index && styles.photoItemDropZone
                    ]}
                    {...createPanResponder(index).panHandlers}
                  >
                    <Image source={{ uri: photo }} style={styles.uploadedPhoto} />
                    <TouchableOpacity 
                      style={styles.removePhotoButton}
                      onPress={() => deletePhoto(index)}
                    >
                      <Text style={styles.removePhotoText}>‚úï</Text>
                    </TouchableOpacity>
                    <View style={styles.photoIndex}>
                      <Text style={styles.photoIndexText}>{index + 1}</Text>
                    </View>
                  </Animated.View>
                ))}
                
                {/* Floating Photo */}
                {isDragging && draggedIndex !== null && (
                  <Animated.View 
                    style={[
                      styles.floatingPhoto,
                      {
                        transform: [
                          { scale: floatingPhoto.scale },
                          { translateX: floatingPhoto.translateX },
                          { translateY: floatingPhoto.translateY },
                          { 
                            rotate: floatingPhoto.rotate.interpolate({
                              inputRange: [0, 1],
                              outputRange: ['0deg', '5deg'],
                            })
                          },
                        ],
                        opacity: floatingPhoto.opacity,
                      },
                    ]}
                    pointerEvents="none"
                  >
                    <Image 
                      source={{ uri: editingPhotos[draggedIndex] }} 
                      style={styles.floatingPhotoImage} 
                    />
                    <View style={styles.floatingPhotoShadow} />
                  </Animated.View>
                )}
                
                {/* Add Photo Button */}
                {editingPhotos.length < 7 && (
                  <TouchableOpacity style={styles.addPhotoButton} onPress={addNewPhoto}>
                    <View style={styles.addPhotoPlaceholder}>
                      <Text style={styles.addPhotoIcon}>üì∑</Text>
                      <Text style={styles.addPhotoText}>Fotoƒüraf Ekle</Text>
                    </View>
                  </TouchableOpacity>
                )}
              </View>
      </ScrollView>
            
            <View style={styles.photoManagementActions}>
              <TouchableOpacity 
                style={styles.photoManagementCancelButton}
                onPress={closePhotoManagement}
              >
                <Text style={styles.photoManagementCancelText}>ƒ∞ptal</Text>
              </TouchableOpacity>
              <TouchableOpacity 
                style={styles.photoManagementSaveButton}
                onPress={savePhotoChanges}
              >
                <Text style={styles.photoManagementSaveText}>Kaydet</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </EnterpriseLayout>
  );
};

const styles = StyleSheet.create({
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: spacing.xl,
  },
  errorText: {
    color: '#FFFFFF',
    fontSize: 18,
    marginBottom: spacing.lg,
    textAlign: 'center',
  },
  profileInfoContainer: {
    backgroundColor: '#000000',
    padding: spacing.lg,
    marginTop: -60,
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
  },
  photoSection: {
    marginBottom: spacing.lg,
  },
  profileHeader: {
    flexDirection: 'row',
    alignItems: 'flex-end',
    marginTop: spacing.xl, // Add top margin to move down
    marginBottom: spacing.lg,
  },
  photoGalleryContainer: {
    width: screenWidth - spacing.lg * 2,
    minHeight: screenHeight * 0.4, // Minimum height to ensure visibility
    marginTop: spacing.xl, // Separate from name area
    marginBottom: spacing.lg,
    alignSelf: 'center', // Center the container
  },
  photoScrollView: {
    width: '100%',
    height: screenHeight * 0.4, // Fixed height for visibility
    alignSelf: 'center', // Center the scroll view
  },
  photoScrollContent: {
    alignItems: 'center',
    paddingRight: 0,
  },
  photoCard: {
    width: screenWidth - spacing.lg * 2,
    height: screenHeight * 0.4, // Fixed height for visibility
    position: 'relative',
    alignItems: 'center',
    justifyContent: 'center',
  },
  photoCardTouchable: {
    width: '100%',
    height: '100%',
    alignItems: 'center',
    justifyContent: 'center',
  },
  photoCardImage: {
    width: '100%',
    height: '100%',
    borderRadius: 16,
    backgroundColor: '#f0f0f0',
  },
  photoGallery: {
    width: '100%',
    height: '100%',
  },
  currentPhotoContainer: {
    width: '100%',
    height: '100%',
    borderRadius: 16,
    overflow: 'hidden',
    borderWidth: 2,
    borderColor: '#E50914',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 4,
    },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 8,
    position: 'relative',
  },
  photoLayer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    borderRadius: 14,
    overflow: 'hidden',
  },
  photoOverlayElements: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    pointerEvents: 'none',
  },
  currentPhotoTouchable: {
    width: '100%',
    height: '100%',
    position: 'relative',
  },
  currentPhoto: {
    width: '100%',
    height: '100%',
  },
  photoCounterOverlay: {
    position: 'absolute',
    top: spacing.md,
    left: spacing.md,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.xs,
    borderRadius: 12,
  },
  photoCounterText: {
    color: '#FFFFFF',
    fontSize: 12,
    fontWeight: '600',
  },
  photoPlaceholder: {
    width: '100%',
    height: '100%',
    borderRadius: 16,
    backgroundColor: '#1A1A1A',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#E50914',
    borderStyle: 'dashed',
  },
  photoPlaceholderText: {
    fontSize: 40,
    color: '#666',
  },
  photoPlaceholderSubtext: {
    fontSize: 10,
    color: '#666',
    marginTop: 4,
  },
  photoIndicatorsContainer: {
    marginTop: spacing.md,
    alignItems: 'center',
    paddingVertical: spacing.sm,
  },
  photoIndicators: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: spacing.sm,
  },
  photoIndicator: {
    width: 12,
    height: 12,
    borderRadius: 6,
    backgroundColor: 'rgba(255, 255, 255, 0.3)',
    marginHorizontal: 4,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.5)',
  },
  photoIndicatorActive: {
    backgroundColor: '#E50914',
    borderColor: '#E50914',
    transform: [{ scale: 1.2 }],
  },
  photoIndicatorInner: {
    width: 6,
    height: 6,
    borderRadius: 3,
    backgroundColor: '#FFFFFF',
  },
  photoProgressContainer: {
    width: 120,
    height: 3,
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
    borderRadius: 2,
    overflow: 'hidden',
  },
  photoProgressBar: {
    height: '100%',
    backgroundColor: '#E50914',
    borderRadius: 2,
  },
  verifiedBadge: {
    position: 'absolute',
    bottom: spacing.md,
    right: spacing.md,
    backgroundColor: '#10B981',
    borderRadius: 12,
    width: 24,
    height: 24,
    justifyContent: 'center',
    alignItems: 'center',
  },
  verifiedText: {
    fontSize: 12,
  },
  profileInfo: {
    flex: 1,
  },
  profileName: {
    color: '#FFFFFF',
    fontSize: 28,
    fontWeight: 'bold',
    marginBottom: spacing.xs,
  },
  premiumBadge: {
    fontSize: 24,
    marginLeft: spacing.xs,
  },
  profileUsername: {
    color: '#8C8C8C',
    fontSize: 16,
    marginBottom: spacing.sm,
  },
  profileBio: {
    color: '#FFFFFF',
    fontSize: 16,
    lineHeight: 24,
    marginBottom: spacing.sm,
  },
  locationContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  locationIcon: {
    fontSize: 16,
    marginRight: spacing.xs,
  },
  profileLocation: {
    color: '#8C8C8C',
    fontSize: 14,
  },
  socialStats: {
    justifyContent: 'space-around',
    paddingVertical: spacing.md,
    borderTopWidth: 1,
    borderTopColor: '#333333',
  },
  socialStat: {
    alignItems: 'center',
  },
  socialStatNumber: {
    color: '#FFFFFF',
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: spacing.xs,
  },
  socialStatLabel: {
    color: '#8C8C8C',
    fontSize: 12,
  },
  sectionContainer: {
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.md,
  },
  sectionTitle: {
    color: '#FFFFFF',
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: spacing.md,
  },
  statsCard: {
    padding: spacing.lg,
  },
  statItem: {
    alignItems: 'center',
    padding: spacing.md,
  },
  statIcon: {
    fontSize: 32,
    marginBottom: spacing.sm,
  },
  statNumber: {
    color: '#FFFFFF',
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: spacing.xs,
  },
  statLabel: {
    color: '#8C8C8C',
    fontSize: 12,
    textAlign: 'center',
  },
  moviesScrollView: {
    marginHorizontal: -spacing.lg,
  },
  movieCard: {
    marginLeft: spacing.lg,
    width: 120,
  },
  moviePoster: {
    width: 120,
    height: 180,
    borderRadius: 12,
    marginBottom: spacing.sm,
  },
  movieTitle: {
    color: '#FFFFFF',
    fontSize: 14,
    fontWeight: '600',
    marginBottom: spacing.xs,
  },
  movieRating: {
    color: '#E50914',
    fontSize: 12,
  },
  interestsCard: {
    padding: spacing.lg,
  },
  interestsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.sm,
  },
  interestChip: {
    backgroundColor: 'rgba(229, 9, 20, 0.2)',
    borderColor: '#E50914',
  },
  interestChipText: {
    color: '#E50914',
  },
  genresCard: {
    padding: spacing.lg,
  },
  genresContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.sm,
  },
  genreChip: {
    backgroundColor: '#E50914',
  },
  genreChipText: {
    color: '#FFFFFF',
  },
  activityCard: {
    padding: spacing.lg,
  },
  activityItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: spacing.md,
    borderBottomWidth: 1,
    borderBottomColor: '#333333',
  },
  activityIcon: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#1A1A1A',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: spacing.md,
  },
  activityIconText: {
    fontSize: 20,
  },
  activityContent: {
    flex: 1,
  },
  activityTitle: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
    marginBottom: spacing.xs,
  },
  activityTime: {
    color: '#8C8C8C',
    fontSize: 12,
  },
  activityPoster: {
    width: 40,
    height: 60,
    borderRadius: 6,
  },
  lastWatchedCard: {
    padding: spacing.lg,
  },
  lastWatchedPoster: {
    width: 80,
    height: 120,
    borderRadius: 8,
  },
  lastWatchedInfo: {
    flex: 1,
  },
  lastWatchedTitle: {
    color: '#FFFFFF',
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: spacing.sm,
  },
  lastWatchedTime: {
    color: '#8C8C8C',
    fontSize: 14,
    marginBottom: spacing.md,
  },
  bottomSpacing: {
    height: spacing.xl,
  },
  profileBioPlaceholder: {
    color: '#8C8C8C',
    fontSize: 16,
    fontStyle: 'italic',
    marginBottom: spacing.sm,
  },
  profileUsernamePlaceholder: {
    color: '#8C8C8C',
    fontSize: 14,
    fontStyle: 'italic',
    marginBottom: spacing.sm,
  },
  locationPlaceholder: {
    color: '#8C8C8C',
    fontSize: 14,
    fontStyle: 'italic',
  },
  personalInfoContainer: {
    marginTop: spacing.md,
    gap: spacing.sm,
  },
  personalInfoItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: spacing.xs,
  },
  personalInfoIcon: {
    fontSize: 16,
    marginRight: spacing.sm,
  },
  personalInfoText: {
    color: '#FFFFFF',
    fontSize: 14,
    fontWeight: '500',
  },
  emptyInterestsContainer: {
    alignItems: 'center',
    paddingVertical: spacing.lg,
  },
  emptyInterestsText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '500',
    marginBottom: spacing.xs,
    textAlign: 'center',
  },
  emptyInterestsSubtext: {
    color: '#8C8C8C',
    fontSize: 14,
    textAlign: 'center',
    fontStyle: 'italic',
  },
  // Personal Info Section Styles
  personalInfoSection: {
    marginTop: spacing.md,
  },
  personalInfoRow: {
    marginBottom: spacing.sm,
  },
  visibilityButton: {
    padding: spacing.xs,
    marginRight: spacing.xs,
  },
  visibilityIcon: {
    fontSize: 16,
  },
  // Favorites Section Styles
  favoritesCard: {
    padding: spacing.lg,
  },
  favoritesContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.sm,
  },
  favoriteItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(229, 9, 20, 0.1)',
    paddingHorizontal: spacing.md,
    paddingVertical: spacing.sm,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: '#E50914',
  },
  favoriteItemIcon: {
    fontSize: 14,
    marginRight: spacing.xs,
  },
  favoriteItemText: {
    color: '#E50914',
    fontSize: 12,
    fontWeight: '500',
  },
  emptyFavoritesContainer: {
    alignItems: 'center',
    paddingVertical: spacing.lg,
  },
  emptyFavoritesText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '500',
    marginBottom: spacing.xs,
    textAlign: 'center',
  },
  emptyFavoritesSubtext: {
    color: '#8C8C8C',
    fontSize: 14,
    textAlign: 'center',
    fontStyle: 'italic',
  },
  favoriteMovieItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: spacing.sm,
    paddingHorizontal: spacing.md,
    marginBottom: spacing.sm,
    backgroundColor: '#f8f9fa',
    borderRadius: 12,
  },
  favoriteMoviePoster: {
    width: 140,
    height: 210,
    borderRadius: 0,
    marginRight: 0,
  },
  favoriteMovieInfo: {
    flex: 1,
  },
  favoriteMovieTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: spacing.xs,
  },
  favoriteMovieYear: {
    fontSize: 14,
    color: '#666',
    marginBottom: spacing.xs,
  },
  favoriteMovieType: {
    fontSize: 12,
    color: '#888',
    fontWeight: '500',
  },
  favoritesFilterRow: {
    flexDirection: 'row',
    marginBottom: spacing.md,
    paddingHorizontal: spacing.lg,
    justifyContent: 'center',
  },
  favoritesFilterButton: {
    flex: 1,
    paddingVertical: spacing.md,
    paddingHorizontal: spacing.lg,
    marginHorizontal: spacing.sm,
    backgroundColor: '#f0f0f0',
    borderRadius: 25,
    alignItems: 'center',
    borderWidth: 2,
    borderColor: 'transparent',
  },
  favoritesFilterButtonActive: {
    backgroundColor: '#E50914',
    borderColor: '#E50914',
  },
  favoritesFilterButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#666',
  },
  favoritesFilterButtonTextActive: {
    color: '#FFFFFF',
  },
  favoritesScrollView: {
    marginHorizontal: -spacing.md,
  },
  favoritesScrollContent: {
    paddingHorizontal: spacing.md,
  },
  favoriteMovieCard: {
    width: 140,
    marginRight: spacing.md,
    backgroundColor: '#fff',
    borderRadius: 16,
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 8,
    elevation: 5,
    borderWidth: 1,
    borderColor: '#f0f0f0',
  },
  favoriteMovieCardInfo: {
    padding: spacing.md,
    backgroundColor: '#fff',
  },
  favoriteMovieCardTitle: {
    fontSize: 14,
    fontWeight: '700',
    color: '#333',
    marginBottom: spacing.xs,
    textAlign: 'center',
    lineHeight: 18,
  },
  favoriteMovieCardYear: {
    fontSize: 12,
    color: '#666',
    textAlign: 'center',
    marginBottom: spacing.sm,
    fontWeight: '500',
  },
  favoriteMovieCardType: {
    alignItems: 'center',
    backgroundColor: '#E50914',
    paddingVertical: spacing.xs,
    paddingHorizontal: spacing.sm,
    borderRadius: 12,
  },
  favoriteMovieCardTypeText: {
    fontSize: 11,
    color: '#FFFFFF',
    fontWeight: '600',
  },
  emptyStateCard: {
    padding: spacing.xl,
    alignItems: 'center',
  },
  emptyStateContainer: {
    alignItems: 'center',
  },
  emptyStateIcon: {
    fontSize: 48,
    marginBottom: spacing.md,
  },
  emptyStateText: {
    color: '#FFFFFF',
    fontSize: 18,
    fontWeight: '600',
    marginBottom: spacing.sm,
    textAlign: 'center',
  },
  emptyStateSubtext: {
    color: '#8C8C8C',
    fontSize: 14,
    textAlign: 'center',
  },
  zoomModalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.9)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  zoomModalContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: spacing.lg,
  },
  zoomCloseButton: {
    position: 'absolute',
    top: 50,
    right: 20,
    zIndex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    borderRadius: 20,
    width: 40,
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
  zoomCloseText: {
    color: '#FFFFFF',
    fontSize: 20,
    fontWeight: 'bold',
  },
  zoomedImage: {
    width: screenWidth - 40,
    height: screenHeight - 200,
  },
  // Photo Management Modal Styles
  photoManagementModal: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.8)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  photoManagementContainer: {
    backgroundColor: '#1A1A1A',
    borderRadius: 20,
    width: screenWidth - 40,
    height: screenHeight * 0.8,
    padding: spacing.lg,
  },
  photoManagementHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: spacing.lg,
    paddingBottom: spacing.md,
    borderBottomWidth: 1,
    borderBottomColor: '#333',
  },
  photoManagementTitle: {
    color: '#FFFFFF',
    fontSize: 20,
    fontWeight: 'bold',
  },
  photoManagementSubtitle: {
    color: '#8C8C8C',
    fontSize: 14,
    marginTop: spacing.xs,
  },
  photoManagementCloseButton: {
    width: 30,
    height: 30,
    borderRadius: 15,
    backgroundColor: '#333',
    justifyContent: 'center',
    alignItems: 'center',
  },
  photoManagementCloseText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  photoManagementContent: {
    flex: 1,
  },
  photoManagementWarning: {
    backgroundColor: 'rgba(255, 193, 7, 0.1)',
    borderWidth: 1,
    borderColor: '#FFC107',
    borderRadius: 8,
    padding: spacing.md,
    marginBottom: spacing.md,
  },
  photoManagementWarningText: {
    color: '#FFC107',
    fontSize: 14,
    textAlign: 'center',
    fontWeight: '500',
  },
  photoManagementGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.sm,
  },
  photoManagementItem: {
    position: 'relative',
    width: (screenWidth - 80 - spacing.sm * 2) / 3,
    height: ((screenWidth - 80 - spacing.sm * 2) / 3) * 1.33,
    borderRadius: 12,
    overflow: 'hidden',
    borderWidth: 2,
    borderColor: '#E50914',
  },
  photoManagementItemDragging: {
    opacity: 0.7,
    transform: [{ scale: 1.05 }],
    borderColor: '#FFC107',
    borderWidth: 3,
  },
  photoManagementImage: {
    width: '100%',
    height: '100%',
  },
  photoManagementOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.2)',
    justifyContent: 'space-between',
    alignItems: 'flex-end',
    padding: spacing.sm,
  },
  photoManagementDeleteButton: {
    width: 28,
    height: 28,
    borderRadius: 14,
    backgroundColor: 'rgba(255, 0, 0, 0.9)',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#FFFFFF',
  },
  photoManagementDeleteText: {
    fontSize: 14,
    color: '#FFFFFF',
    fontWeight: 'bold',
  },
  photoManagementDragHandle: {
    width: 28,
    height: 28,
    borderRadius: 14,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#FFFFFF',
  },
  photoManagementDragText: {
    fontSize: 12,
    color: '#FFFFFF',
    fontWeight: 'bold',
  },
  photoManagementIndex: {
    position: 'absolute',
    bottom: 4,
    left: 4,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    color: '#FFFFFF',
    fontSize: 10,
    paddingHorizontal: 4,
    paddingVertical: 2,
    borderRadius: 4,
  },
  photoManagementAddButton: {
    width: (screenWidth - 80 - spacing.sm * 2) / 3,
    height: ((screenWidth - 80 - spacing.sm * 2) / 3) * 1.33,
    borderRadius: 12,
    borderWidth: 2,
    borderColor: '#E50914',
    borderStyle: 'dashed',
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#0F0F0F',
  },
  photoManagementAddText: {
    fontSize: 24,
    marginBottom: spacing.xs,
  },
  photoManagementAddLabel: {
    color: '#E50914',
    fontSize: 12,
    fontWeight: '600',
  },
  photoManagementEmptyState: {
    width: '100%',
    height: 200,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#E50914',
    borderStyle: 'dashed',
    borderRadius: 12,
    marginBottom: spacing.md,
  },
  photoManagementEmptyText: {
    fontSize: 48,
    marginBottom: spacing.sm,
  },
  photoManagementEmptyLabel: {
    fontSize: 16,
    color: '#E50914',
    fontWeight: '600',
    marginBottom: spacing.xs,
  },
  photoManagementEmptySubtext: {
    fontSize: 14,
    color: '#8C8C8C',
    textAlign: 'center',
  },
  // Photo Grid Styles - Like Registration Screen
  photoGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.sm,
    marginBottom: spacing.md,
  },
  photoItem: {
    position: 'relative',
    width: (screenWidth - spacing.lg * 2 - spacing.sm * 2) / 3,
    height: ((screenWidth - spacing.lg * 2 - spacing.sm * 2) / 3) * 1.33, // 3:4 ratio for dating app
    borderRadius: 12,
    overflow: 'hidden',
  },
  photoItemDragging: {
    opacity: 0.5,
    transform: [{ scale: 0.95 }],
  },
  uploadedPhoto: {
    width: '100%',
    height: '100%',
    borderRadius: 12,
  },
  removePhotoButton: {
    position: 'absolute',
    top: 8,
    right: 8,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    borderRadius: 15,
    width: 30,
    height: 30,
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 10,
  },
  removePhotoText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  photoIndex: {
    position: 'absolute',
    bottom: 8,
    left: 8,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    borderRadius: 12,
    paddingHorizontal: 8,
    paddingVertical: 4,
  },
  photoIndexText: {
    color: '#FFFFFF',
    fontSize: 12,
    fontWeight: '600',
  },
  addPhotoButton: {
    width: (screenWidth - spacing.lg * 2 - spacing.sm * 2) / 3,
    height: ((screenWidth - spacing.lg * 2 - spacing.sm * 2) / 3) * 1.33,
    borderRadius: 12,
    borderWidth: 2,
    borderColor: '#E50914',
    borderStyle: 'dashed',
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(229, 9, 20, 0.1)',
  },
  addPhotoPlaceholder: {
    alignItems: 'center',
  },
  addPhotoButton: {
    width: (screenWidth - spacing.lg * 2 - spacing.sm * 2) / 3,
    height: ((screenWidth - spacing.lg * 2 - spacing.sm * 2) / 3) * 1.33, // 3:4 ratio for dating app
    borderRadius: 12,
    borderWidth: 2,
    borderColor: '#E50914',
    borderStyle: 'dashed',
    backgroundColor: 'rgba(229, 9, 20, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  addPhotoPlaceholder: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  addPhotoIcon: {
    fontSize: 24,
    marginBottom: spacing.xs,
  },
  addPhotoText: {
    color: '#E50914',
    fontSize: 12,
    fontWeight: '600',
    textAlign: 'center',
  },
  // RegisterScreen Styles - Exact same as RegisterScreen
  photoUploadSection: {
    width: '100%',
    marginTop: spacing.sm,
  },
  photoUploadHeader: {
    marginBottom: spacing.md,
  },
  photoUploadTitle: {
    color: '#FFFFFF',
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: spacing.xs,
  },
  photoUploadSubtitle: {
    color: '#8C8C8C',
    fontSize: 14,
  },
  photoGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.sm,
    marginBottom: spacing.md,
  },
  photoItem: {
    position: 'relative',
    width: (screenWidth - spacing.lg * 2 - spacing.sm * 2) / 3,
    height: ((screenWidth - spacing.lg * 2 - spacing.sm * 2) / 3) * 1.33, // 3:4 ratio for dating app
    borderRadius: 12,
    overflow: 'hidden',
    borderWidth: 2,
    borderColor: '#E50914',
  },
  uploadedPhoto: {
    width: '100%',
    height: '100%',
  },
  removePhotoButton: {
    position: 'absolute',
    top: 4,
    right: 4,
    width: 24,
    height: 24,
    borderRadius: 12,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  removePhotoText: {
    color: '#FFFFFF',
    fontSize: 12,
    fontWeight: 'bold',
  },
  photoIndex: {
    position: 'absolute',
    bottom: 4,
    left: 4,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    borderRadius: 8,
    paddingHorizontal: 6,
    paddingVertical: 2,
  },
  photoIndexText: {
    color: '#FFFFFF',
    fontSize: 10,
    fontWeight: 'bold',
  },
  // Drag and Drop Styles - Exact same as RegisterScreen
  photoItemDragging: {
    borderColor: '#FFC107',
    borderWidth: 3,
    zIndex: 1000,
    elevation: 10,
    shadowColor: '#FFC107',
    shadowOffset: {
      width: 0,
      height: 4,
    },
    shadowOpacity: 0.5,
    shadowRadius: 8,
  },
  photoItemDropZone: {
    borderColor: '#4CAF50',
    borderWidth: 3,
    borderStyle: 'dashed',
    backgroundColor: 'rgba(76, 175, 80, 0.1)',
  },
  floatingPhoto: {
    position: 'absolute',
    width: (screenWidth - spacing.lg * 2 - spacing.sm * 2) / 3,
    height: ((screenWidth - spacing.lg * 2 - spacing.sm * 2) / 3) * 1.33,
    borderRadius: 12,
    zIndex: 2000,
    elevation: 20,
  },
  floatingPhotoImage: {
    width: '100%',
    height: '100%',
    borderRadius: 12,
  },
  floatingPhotoShadow: {
    position: 'absolute',
    bottom: -8,
    left: 8,
    right: -8,
    height: 8,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 12,
    zIndex: -1,
  },
  photoManagementActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: spacing.lg,
    paddingTop: spacing.md,
    borderTopWidth: 1,
    borderTopColor: '#333',
  },
  photoManagementCancelButton: {
    flex: 1,
    backgroundColor: '#333',
    paddingVertical: spacing.md,
    borderRadius: 8,
    marginRight: spacing.sm,
    alignItems: 'center',
  },
  photoManagementCancelText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
  },
  photoManagementSaveButton: {
    flex: 1,
    backgroundColor: '#E50914',
    paddingVertical: spacing.md,
    borderRadius: 8,
    marginLeft: spacing.sm,
    alignItems: 'center',
  },
  photoManagementSaveText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
  },
  // Photo Edit Button Styles
  photoEditButton: {
    position: 'absolute',
    bottom: spacing.md,
    right: spacing.md,
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 10,
  },
  photoEditButtonText: {
    fontSize: 18,
  },
  letterboxdContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: spacing.sm,
    paddingVertical: spacing.xs,
  },
  letterboxdIcon: {
    fontSize: 16,
    marginRight: spacing.sm,
  },
  letterboxdText: {
    color: '#E50914',
    fontSize: 14,
    textDecorationLine: 'underline',
  },
  editButton: {
    padding: spacing.xs,
  },
  editIcon: {
    fontSize: 16,
  },
  bioContainer: {
    flex: 1,
  },
  sectionHeader: {
    marginBottom: spacing.md,
  },
});